@{
	ViewBag.Title = "UI (пользовательский интерфейс) для плагинов";
}

<div class="row">
	<div class="col-md-12">
		<h1>UI (пользовательский интерфейс) для плагинов</h1>
		<p>
			Как мы видели в разделе о разработке плагинов, стандартный плагин ListenerPlugin дает возможность
			обрабатывать HTTP запросы (возвращать на клиент файлы из ресурсов или данные в JSON).
			Еще один стандартный плагин WebUIPlugin реализует веб-интерфейс системы.
		</p>
		<p>
			Веб-интерфейс представляет собой что-то вроде панели управления вашим домом. Он состоит из разделов,
			причем каждый плагин может содержать собственные разделы и они автоматически будут отображаться
			в интерфейсе. Все разделы делятся на 2 группы: <em>системные</em> (различные настройки, например, раздел
			сценариев) и <em>пользовательские</em> (разделы, с которыми пользователи работают в повседневной
			жизни, например, "прогноз погоды" и "будильники").
		</p>
		<div class="row">
			<div class="col-md-6">
				<img class="ths-image img-responsive" src="~/Content/images/common-pages.png"
					 alt="Список пользовательских разделов" title="Список пользовательских разделов" />
			</div>
			<div class="col-md-6">
				<img class="ths-image img-responsive" src="~/Content/images/system-pages.png"
					 alt="Список системных разделов" title="Список системных разделов" />
			</div>
		</div>
		<p>
			Кроме этих "рабочих" разделов имеется еще один специальный раздел — "рабочий стол"
			(он же "стартовая страничка"). Там находятся "элементы стартовой страницы" — небольшие панели,
			которые отображают полезную информацию. При клике на них происходит переход в какой-либо раздел
			или выполняется действие. Стартовая страница (как и весь остальной интерфейс) корректно отображается
			как на больших экранах, так и на небольших экранах мобильных устройств.
		</p>
		<div class="row">
			<div class="col-md-3">
				<img class="ths-image img-responsive" src="~/Content/images/start-page-small.png"
					 alt="Стартовая страница на маленьком экране" title="Стартовая страница на маленьком экране" />
			</div>
			<div class="col-md-9">
				<img class="ths-image img-responsive" src="~/Content/images/start-page-large.png"
					 alt="Стартовая страница на большом экране" title="Стартовая страница на большом экране" />
			</div>
		</div>
		<p>
			Технически, веб-интерфейс представляет собой модульное одностраничное приложение на основе
			<a href="http://marionettejs.com" target="_blank">marionette.js</a>. Загрузка модулей
			происходит по мере необходимости с помощью <a href="http://requirejs.org" target="_blank">require.js</a>.
			Для визуальной части используется <a href="http://getbootstrap.com" target="_blank">Twitter Bootstrap</a>.
		</p>
		<h2>Добавление нового раздела</h2>
		<p>
			Любой раздел системы - это небольшая программа на языке JavaScript. Она описывает, что именно
			должен видеть пользователь на экране и какие действия должны быть выполнены, когда пользователь
			взаимодействует с элементами интерфейса.
		</p>
		<p>
			Для добавления нового раздела в систему необходимо в проекте вашего плагина создать js файл,
			который будет содержать js-код раздела. Веб-интерфейс загружает разделы через
			<a href="http://requirejs.org" target="_blank">require.js</a>,
			поэтому для определения раздела используйте функцию <code>define</code> (т.е. каждый раздел -
			это отдельный модуль в терминах require.js).
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore'],
	function (application, marionette, backbone, _) {
		var module = {
		<strong>start</strong>: function () {
				alert("module started!");
			}
		};
		return module;
	});
</pre>
		<p>
			Как видите, функция <code>define</code> принимает два параметра:
		</p>
		<ol>
			<li>Массив зависимостей - содержит имена модулей, от котрых зависит ваш модуль.</li>
			<li>
				Функция инициализации - будет вызвана один раз, при
				загрузке вашего модуля. Она должна возвращать объект, представляющий
				ваш модуль.
			</li>
		</ol>
		<p>
			Каждый модуль из списка зависимостей будет передан как входной параметр в функцию
			инициализации. В примере указано две зависимости: 'app' - это предопределенное имя
			основного модуля приложения (например, с его помощью можно отображать информацию
			на экране), 'marionette' - это предопределенное имя модуля библиотеки
			<a href="http://marionettejs.com" target="_blank">marionette.js</a>
			(там содержатся средства, облегчающие разработку пользовательского интерфейса).
			'backbone' - предопределенное имя модуля библиотеки
			<a href="http://backbonejs.org/" target="_blank">backbone.js</a>.
		</p>
		<p>
			Для того, чтобы модуль мог быть использован веб-интерфейсом, необходимо, чтобы он
			содержал метод с названием <strong>start</strong>. По сути, когда пользователь
			нажимает на ссылку перехода в какой-либо раздел, система загружает js-файл раздела
			при помощи require.js, далее вызывается функция инициализации (если это не было
			сделано ранее) и у объекта, полученного из функции инициализации, вызывается метод
			<strong>start</strong>.
		</p>
		<p>
			В приведенном выше примере модуль ничего не отображает на странице. Он просто
			выдает пользователю alert с текстом "module started!".
		</p>

		<p>
			Далее необходимо настроить загрузку js-файла раздела в браузер. Для этого в свойствах файла
			укажите для параметра <em>Build action</em> значение <em>EmbeddedResource</em> и задайте
			URL для файла.
		</p>
		<p>
			Для того, чтобы указать URL, пометьте свой плагин атрибутом <code>ThinkingHome.Plugins.WebUI.Attributes.AppSection</code>
			из сборки <code>ThinkingHome.Plugins.WebUI</code> (если вы еще не добавили ее к проекту, самый простой способ сделать это - набрать в консоли
			Nuget Package Manager <kbd>Install-Package ThinkingHome.Plugins.WebUI</kbd>)
		</p>
		<pre>
[Plugin]
[AppSection(<strong>"My plugin"</strong>,		// название рездела
		<strong>SectionType.Common</strong>,		// тип раздела
		<strong>"/my-plugin/my-file.js"</strong>,	// URL
		<strong>"ThinkingHome.Plugins.MyPlugin.Resources.my-file.js"</strong>)]
public class MyPlugin : PluginBase
{
	...
}
</pre>
		<p>
			Кроме URL и пути к файлу ресурса, в параметрах атрибута <code>[AppSection]</code>
			необходимо указать название раздела и его тип ("пользовательский" или "системный"). После этого ссылка на раздел автоматически
			добавится в нужный список разделов.
		</p>
		<p>
			<img class="img-responsive ths-image" src="~/Content/images/section-in-list.png" />
		</p>
		<h2>Отображение данных на странице</h2>
		<p>
			Данные появляются в модуле из источника данных (например они могут быть получены с сервера или введены пользователем).
			Будем считать, что изначально данные существуют в виде объектов JavaScript. Для примера создадим объекты внутри приложения.
		</p>
		<pre>
start: function () {
	...
	var items = [
		{ id: 1, name: 'Lev Tolstoy' },
		{ id: 2, name: 'Ivan Turgenev' },
		{ id: 3, name: 'Nikolay Gogol' },
		{ id: 4, name: 'Alexander Pushkin' }
	];
	
	var model = new backbone.Collection(items);
	...
}
</pre>
		<p>
			В приведенном примере мы создали массив объектов, каждый из которых имеет два поля: id (номер объекта) и name (текстовое поле).
			Также мы создали специальный объект - модель для нашего нашего массива (с помощью библиотеки Backbone.js). Благодаря Backbone.js
			мы имеем средства для удобной работы с нашими объектами. Например, мы легко можем задать порядок сортировки для коллекции
			и при обращении к ее элементам они будут выдаваться в нужном порядке.
		</p>
		<pre>
		...
		var model = new backbone.Collection(items);
		model.comparator = 'name';
		
		model.sort();
		model.each(function(obj) {
			console.log(obj.get('name'));
		});
		
		/*
			будет выведено:
				Alexander Pushkin
				Ivan Turgenev
				Lev Tolstoy
				Nikolay Gogol
		*/
</pre>
		<p>
			Обратите внимание, объект <code>backbone</code>, к которому мы обращались при создании модели - это входной параметр нашей функции инициализации
			модуля. Это третий по списку параметр, а значит, в качестве его значения будет передан объект, соответствующий третьему пункту нашего списка
			зависимостей (т.е. туда будет передан объект Backbone из библиотеки backbone.js).
		</p>
		<p>
			Для отображения данных в системе используются представления (views) из marionette.js. Представления - это специальные объекты,
			которые знают, как отобразить данные на странице и какие события сгенерировать при взаимодействии пользователя
			с элементами интерфейса.
		</p>
		<p>
			Сначала необходимо описать параметры представления и его поведения. Далее нужно создать его объект - экземпляр представления
			и передать туда модель с данными. После этого нужно вызвать команду "отобразить представление на странице".
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore'],
	function (application, marionette, backbone, _) {

		<strong>// описываем параметры представлений для коллекции и для ее отдельного элемента</strong>
		var peopleView = marionette.ItemView.extend({
				template: _.template('<%= name %> (<%= id %>)')			<strong>// шаблон отображения</strong>
			});
		
		var peoplesView = marionette.CompositeView.extend({
				template: _.template('&lt;h1>Peoples&lt;/h1>&lt;div id="list">&lt;/div>'),	<strong>// шаблон отображения</strong>
				childView: peopleView,			<strong>// представление для элемента коллекции</strong>
				childViewContainer: '#list'		<strong>// контейнер, куда будут добавляться элементы</strong>
			});
		
		
		var module = {
			<strong>start</strong>: function () {
				...
		
				<strong>// создаем экземпляр представления и передаем туда данные (модель Backbone.Collection)</strong>
				var view = new peoplesView({ collection: model });
	
				<strong>// отображаем представление на странице</strong>
				application.setContentView(view);
			}
		};
		return module;
	});
</pre>
		<p>
			Обратите внимание, объекты marionette и application - это тоже входные параметры функции инициализации.
		</p>
		<p>
			Как видите, представление определяется при помощи вызова функции <code>extend</code> для одного из
			базовых представлений из библиотеки marionette.js. В функцию <code>extend</code> передается объект,
			определяющий параметры, которыми будет расширено базовое представление.
		</p>
		<p>
			Для отображения объекта с данными используйте базовое представление 
			<a target="_blank" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.itemview.md">marionette.ItemView</a>.
			Для него необходимо задать только шаблон отображения. При создании экземпляра представления
			объект с данными (Backbone.Model) нужно поместить в поле <code>model</code>.
		</p>
		<pre>
<strong>// определяем параметры представления</strong>
var myView = marionette.ItemView.extend({
	template: _.template('<%= id %>: <%= field1 %> (<%= field2 %>)')
});
...

<strong>// создаем экземпляр представления</strong>
var view = new myView({ <strong>model</strong>: myDataObject });
...
</pre>
		<p>
			Для отображения <em>коллекции</em> объектов используйте базовое представление 
			<a target="_blank" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.compositeview.md">marionette.CompositeView</a>.
			Кроме шаблона, необходимо указать представление для отображения дочерних объектов
			(элементов коллекции) и селектор для контейнера, в который будет добавлена разметка для дочерних объектов.
			
			При создании экземпляра представления
			объект с данными (Backbone.Collection) нужно поместить в поле <code>collection</code>.
		</p>
		<pre>
<strong>// определяем параметры представления</strong>
var myListView = marionette.CompositeView.extend({
	template: _.template('&lt;h1>Title&lt;/h1>&lt;div id="list">&lt;/div>'),
	<strong>childView</strong>: myView,
	<strong>childViewContainer</strong>: '#list'
});
<strong>// создаем экземпляр представления</strong>
var view = new myListView({ <strong>collection</strong>: myCollection });
...
</pre>
		<p>
			Шаблон - это строка, содержащая HTML разметку для отображения объекта с данными. Для формирования
			разметки по шаблону используется движок шаблонов из библиотеки 
			<a href="http://underscorejs.org/#template" target="_blank">underscore.js</a>.
			Места для вставки значений полей объекта обозначаются конструкцией <code>&lt;%= fieldName %></code>,
			где <em>fieldName</em> - это название поля объекта. Если необходимо, чтобы при выводе значения поля
			экранировались символы HTML, используйте конструкцию вида <code>&lt;<strong>%-</strong> fieldName %></code>.
		</p>
		<pre>
var data = { title: 'Test', content: '&lt;p>This is content.&lt;/p>'}

var t1 = _.template('<%= title %>&lt;br /><%= content %>)');	// будет выведено: <strong>Test&lt;br />&lt;p>This is content.&lt;/p></strong>

var t2 = _.template('<%= title %>&lt;br /><%- content %>)');	// будет выведено: <strong>Test&lt;br />&amp;lt;p&amp;gt;This is content.&amp;lt;/p&amp;gt;</strong>
</pre>
		<h3>Размещение шаблонов в отдельных файлах</h3>
		<p>
			В предыдущем примере мы использовали для отображения данных очень простые шаблоны и они были
			размещены непосредственно в коде (шаблоны в виде строки передавались в функцию <code>_.template</code>). 
			Например:
		</p>
		<pre>
...
template: _.template(<strong>'<%= name %> (<%= id %>)'</strong>)
...
</pre>
		<p>
			Для небольших шаблонов такой подход довольно удобен, но более сложные шаблоны удобнее будет вынести в отдельные файлы.
		</p>
		<ul>
			<li>не нужно будет беспокоиться об экранировании кавычек (в отличие от варианта с размещением шаблонов в коде);</li>
			<li>будет работать подсветка и автокомплит в IDE;</li>
			<li>глядя на файловую структуру сразу будет понятно, где находятся шаблоны:</li>
			<li>и т.д.</li>
		</ul>
		<p>
			Для подключения шаблонов из отдельных файлов, в первую очередь, нужно поместить файлы с шаблонами
			в ресурсы плагина и настроить доступ к ним по  HTTP. Для этого необходимо установить для файлов с 
			шаблонами параметр <em>Build action</em> = <em>EmbeddedResource</em>, пометить класс плагина 
			атрибутом <code>ThinkingHome.Plugins.Listener.Attributes.HttpResourceAttribute</code> 
			(нужно добавить отдельный атрибут для каждого файла шаблона). В параметрах атрибута
			<code>[HttpResource]</code> необходимо указать путь к файлу ресурсов и URL, котрый будет использоваться 
			для загрузки файла по протоколу HTTP.
		</p>
		<p>
			В стандартных плагинах файлы шаблонов имеют расширение .tpl (соткращение от "template"). Рекомендуем вам
			использовать это же расширение для ваших шаблонов (хотя это и не обязательно - по большому счету, расширение
			может быть любым).
		</p>
		<p>
			Вот пример подключнения шаблона для страницы с прогнозом погоды:
		</p>
		<pre>
[HttpResource(
	"/webapp/weather/forecast.tpl",						<strong>// URL для загрузки файла</strong>
	"ThinkingHome.Plugins.Weather.Resources.js.forecast.forecast.tpl")]	<strong>// путь к файлу в ресурсах плагина</strong>
public class WeatherUIPlugin : PluginBase
{
	...
}
</pre>
		<p>
			Для обращения к файлам шаблонов на стороне клиента необходимо добавить их в список зависимостей
			модуля в виде <code>text!&lt;URL файла с шаблоном></code>. Содержимое шаблона будет передано как
			входной параметр в функцию инициализации модуля.
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore', <strong>'text!myplugin/mytemplate.tpl'</strong>],
	function (application, marionette, backbone, _, <strong>myTemplate</strong>) {
	
		var myView = marionette.ItemView.extend({
				template: _.template(<strong>myTemplate</strong>)
			});

		var module = {
			<strong>start</strong>: function () {
				
				var model = ...

				var view = new myView({ model: model });
				application.setContentView(view);
			}
		};

		return module;
	});
</pre>
		<h3>Подключение css-файлов</h3>
		<p>
			По умолчанию приложение уже содержит ссылку на стили 
			<a href="http://getbootstrap.com" target="_blank">Twitter Bootstrap</a> 
			и вы можете использовать при верстке css-классы оттуда. Хотя в большинстве случаев стилей из 
			Twitter Bootstrap будет достаточно, скорее всего возникнут ситуации, когда нужно подключить
			дополнительные файлы со стилями. Например, это может потребоваться, если у вас много css-классов
			(и вы хотите вынести их в отдельный файл) или при подключении внешних библиотек, имеющих
			собственные файлы со стилями.
		</p>
		<p>
			Подключить дополнительные файлы стилей очень легко. Необходимо поместить их в ресурсы плагина
			аналогично файлам скриптов (.js) и шаблонов (.tpl). После этого нужно пометить класс плагина
			дополнительным атрибутом <code>ThinkingHome.Plugins.WebUI.Attributes.CssResourceAttribute</code>.
		</p>
		<p>
			Атрибут <code>[CssResource]</code> похож на знакомый нам атрибут <code>[HttpResource]</code>,
			с помощью которого мы задавали URL для файлов шаблонов. Но атрибут <code>[CssResource]</code>
			содержит дополнительный параметр <code><strong>bool</strong> AutoLoad</code>. Если указать
			для него значение <code>true</code>, то файл со стилями будет автоматически подключен в приложение.
		</p>
		<p>
			Например, вот так подключается файл со стилями для погодных иконок:
		</p>
		<pre>
[CssResource(
	"/webapp/weather/css/weather-icons.min.css", 
	"ThinkingHome.Plugins.Weather.Resources.css.weather-icons.min.css", 
	<strong>AutoLoad = true</strong>)]
</pre>
		<h2>События</h2>
		<p>
			При помощи событий вы можете выполнить нужные действия при взаимодействии пользователя в интерфейсом.
			Например, вы можете отобразить сообщение при клике мышью на кнопку или отобразить подсказку при наведении
			курсора мыши на элементы интерфейса.
		</p>
		<p>
			Общий принцип очень простой: вы определяете в параметрах представления, в каких ситуациях нужно
			<em>сгенерировать событие</em>, а потом назначаете функцию-обработчик события. При возникновении
			указанных ситуаций будут автоматически вызваны обработчики событий.
		</p>
		<h3>Определение событий</h3>
		<p>
			Определить события для представления можно при помощи параметра <code>triggers</code>. В качестве его
			значения нужно указать объект, каждое поле котрого соответствует некоторому событию. Название поля 
			описывает ситуацию, в окторой должно генерироваться событие. Сначала пишется тип события (например,
			"click" или "mouseover"), далее через пробел указывается селектор для элемента интерфейса, для которого 
			нужно обрабатывать указанной событие. В качестве значения поля нужно указать <em>имя события</em>. Имя события
			используется для назначения функций-обработчиков события.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	...

	triggers: {
		'<strong>click</strong> .do-something': 'something:do:it',
		'<strong>click</strong> #btn-submit': 'submit:form'
	}
});
</pre>
		<h3>Назначение обработчиков событий</h3>
		<p>
			При создании экземпляра представления можно назначить обработчики событий при помощи функции 
			<code>on</code>. В качестве первого параметра необходимо передать имя события, в качестве второго 
			параметра - функцию, которая будет вызвана при возникновении события.
		</p>
		<pre>
var view = new MyView();

view.on("something:do:it", function(args){
  alert("I DID IT!");
});
</pre>
		<p>
			Внутри функции обработчика события можно обращаться к экземпляру представления при помощи
			переменной <code>this</code>. С ее помощью можно получить доступ к модели (при помощи 
			поля <code>model</code>) и элементам интерфейса (при помощи метода <code>$</code>).
			Также можно обратиться к корневому элементу интерфейса через поле <code>$el</code>.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	template: _.template('&lt;input id="input-bg-color" placeholder="enter new bg color" />')
	triggers: {
		'<strong>change</strong> #input-bg-color': 'color:changed'
	}
});

...
var view = new MyView(model: myObject);

view.on("color:changed", function(){
	
	var newColor = this.$('#input-bg-color').val();
	this.$el.css('background-color', newColor);
});
</pre>
		<p>
			Кроме вызова функции <code>on</code> есть еще один вариант назначения обработчиков событий.
			Вы можете описать в параметрах представления функцию, название которой соответствует названию 
			события в <a href="http://en.wikipedia.org/wiki/CamelCase" target="_blank">camelCase</a> 
			с префиксом <em>"on"</em>.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	...
	triggers: {
		'change #input-bg-color': '<strong>color:changed</strong>'
	},
	<strong>onColorChanged</strong>: function(model: myObject){

		var newColor = this.$('#input-bg-color').val();
		this.model.set('color', newColor);
	}
});
</pre>
		<p>
			По большому счету, указанные способы назначения обработчиков событий отличаются только местом, где
			описана функция-обработчик: в первом случае она описана рядом с кодом, использующим представление,
			а во втором случае - в параметрах представления. Обработчики событий, связанных с <em>операциями над
				                                                                                  элемнетами представления</em> лучше размещать в параметрах представления, а обработчики, связанные
			с <em>предметной областью</em> вашего плагина лучше размещать снаружи. Например, вывод подсказки при
			наведении курсора мыши лучше разместить в представлении, а отправку запроса к серверу при нажатии кнопки
			"Сохранить" лучше разместить в коде, создающем экземпляр представления.
		</p>
		<h3>События дочерних представлений</h3>
		<p>
			Все события дочерних представлений <em>всплывают</em> в родительское представление. При этом к их имени
			добавляется префикс <em>"childview:"</em>. Например, предположим, что у вас есть список, в котором у каждого
			элемента есть кнопка "Удалить" и она генерирует событие "delete:item". В этом случае, в родительском 
			представлении вы можете обработать нажатие на эту кнопку, подписавшись (любым способом) на 
			событие <em>"childview:delete:item"</em>. При этом переменная <code>this</code> смотрит на 
			<em>родительское представление</em>, а дочернее представление, в котором произошло событие,
			передается в функцию-обработчик в качестве первого аргумента.
		</p>
		<pre>
// представление для оторажения элемента коллекции
var MyItemView = marionette.ItemView.extend({
	template: _.template('<%= name %> &lt;a href="#" class="btn-delete">Del&lt;/a>'),
	triggers: {
		'click .btn-delete': <strong>'delete:item'</strong>
	}
});

// представление для отображения коллекции
var listView = marionette.CompositeView.extend({
	...
    childView: MyItemView
});

...
var view = new listView({ collection: model });

view.on(<strong>'childview:delete:item'</strong>, function(<strong>childView</strong>){

	// <strong>this</strong> - родительское представление
	// <strong>childView</strong> - дочернее представление
    var name = childView.model.get('name');
    alert(name + ' deleted!');
});
</pre>
		<h2>Запросы к серверу</h2>
		<p>
		</p>
		<h2>Элементы рабочего стола</h2>
		<p>
		</p>
		<h3>Добавление на рабочий стол</h3>
		<p>
		</p>
		<h3>Иконки</h3>
		<p>
		</p>
		<h3>Действия</h3>
		<p>
		</p>
		<h2>Модули, подключенные по умолчанию</h2>
		<p>
		</p>
	</div>
</div>

