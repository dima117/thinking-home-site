@{
	ViewBag.Title = "UI (пользовательский интерфейс) для плагинов";
}

<div class="row">
	<div class="col-md-12">
		<h1>UI (пользовательский интерфейс) для плагинов</h1>
		<p>
			Как мы видели в разделе о разработке плагинов, стандартный плагин ListenerPlugin дает возможность
			обрабатывать HTTP запросы (возвращать на клиент файлы из ресурсов или данные в JSON).
			Еще один стандартный плагин WebUIPlugin реализует веб-интерфейс системы.
		</p>
		<p>
			Веб-интерфейс представляет собой что-то вроде панели управления вашим домом. Он состоит из разделов,
			причем каждый плагин может содержать собственные разделы и они автоматически будут отображаться
			в интерфейсе. Все разделы делятся на 2 группы: <em>системные</em> (различные настройки, например, раздел
			сценариев) и <em>пользовательские</em> (разделы, с которыми пользователи работают в повседневной
			жизни, например, "прогноз погоды" и "будильники").
		</p>
		<div class="row">
			<div class="col-md-6">
				<img class="ths-image img-responsive" src="~/Content/images/common-pages.png"
					alt="Список пользовательских разделов" title="Список пользовательских разделов" />
			</div>
			<div class="col-md-6">
				<img class="ths-image img-responsive" src="~/Content/images/system-pages.png"
					alt="Список системных разделов" title="Список системных разделов" />
			</div>
		</div>
		<p>
			Кроме этих "рабочих" разделов имеется еще один специальный раздел — "рабочий стол"
			(он же "стартовая страничка"). Там находятся "элементы стартовой страницы" — небольшие панели,
			которые отображают полезную информацию. При клике на них происходит переход в какой-либо раздел
			или выполняется действие. Стартовая страница (как и весь остальной интерфейс) корректно отображается
			как на больших экранах, так и на небольших экранах мобильных устройств.
		</p>
		<div class="row">
			<div class="col-md-3">
				<img class="ths-image img-responsive" src="~/Content/images/start-page-small.png"
					alt="Стартовая страница на маленьком экране" title="Стартовая страница на маленьком экране" />
			</div>
			<div class="col-md-9">
				<img class="ths-image img-responsive" src="~/Content/images/start-page-large.png"
					alt="Стартовая страница на большом экране" title="Стартовая страница на большом экране" />
			</div>
		</div>
		<p>
			Технически, веб-интерфейс представляет собой модульное одностраничное приложение на основе
			<a href="http://marionettejs.com" target="_blank">marionette.js</a>. Загрузка модулей
			происходит по мере необходимости с помощью <a href="http://requirejs.org" target="_blank">require.js</a>.
			Для визуальной части используется <a href="http://getbootstrap.com" target="_blank">Twitter Bootstrap</a>.
		</p>
		<h2 id="create-section">Добавление нового раздела</h2>
		<p>
			Любой раздел системы - это небольшая программа на языке JavaScript. Она описывает, что именно
			должен видеть пользователь на экране и какие действия должны быть выполнены, когда пользователь
			взаимодействует с элементами интерфейса.
		</p>
		<p>
			Для добавления нового раздела в систему необходимо в проекте вашего плагина создать js файл,
			который будет содержать js-код раздела. Веб-интерфейс загружает разделы через
			<a href="http://requirejs.org" target="_blank">require.js</a>,
			поэтому для определения раздела используйте функцию <code>define</code> (т.е. каждый раздел -
			это отдельный модуль в терминах require.js).
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore'],
	function (application, marionette, backbone, _) {
		var module = {
			<strong>start</strong>: function () {
				alert("module started!");
			}
		};
		return module;
	});
</pre>
		<p>
			Как видите, функция <code>define</code> принимает два параметра:
		</p>
		<ol>
			<li>Массив зависимостей - содержит имена модулей, от котрых зависит ваш модуль.</li>
			<li>Функция инициализации - будет вызвана один раз, при
				загрузке вашего модуля. Она должна возвращать объект, представляющий
				ваш модуль.
			</li>
		</ol>
		<p>
			Каждый модуль из списка зависимостей будет передан как входной параметр в функцию
			инициализации. В примере указано две зависимости: 'app' - это предопределенное имя
			основного модуля приложения (например, с его помощью можно отображать информацию
			на экране), 'marionette' - это предопределенное имя модуля библиотеки
			<a href="http://marionettejs.com" target="_blank">marionette.js</a>
			(там содержатся средства, облегчающие разработку пользовательского интерфейса).
			'backbone' - предопределенное имя модуля библиотеки
			<a href="http://backbonejs.org/" target="_blank">backbone.js</a>.
		</p>
		<p>
			Для того, чтобы модуль мог быть использован веб-интерфейсом, необходимо, чтобы он
			содержал метод с названием <strong>start</strong>. По сути, когда пользователь
			нажимает на ссылку перехода в какой-либо раздел, система загружает js-файл раздела
			при помощи require.js, далее вызывается функция инициализации (если это не было
			сделано ранее) и у объекта, полученного из функции инициализации, вызывается метод
			<strong>start</strong>.
		</p>
		<p>
			В приведенном выше примере модуль ничего не отображает на странице. Он просто
			выдает пользователю alert с текстом "module started!".
		</p>

		<p>
			Далее необходимо настроить загрузку js-файла раздела в браузер. Для этого в свойствах файла
			укажите для параметра <em>Build action</em> значение <em>EmbeddedResource</em> и задайте
			URL для файла.
		</p>
		<p>
			Для того, чтобы указать URL, пометьте свой плагин атрибутом <code>ThinkingHome.Plugins.WebUI.Attributes.AppSection</code>
			из сборки <code>ThinkingHome.Plugins.WebUI</code> (если вы еще не добавили ее к проекту, самый простой способ сделать это - набрать в консоли
			Nuget Package Manager <kbd>Install-Package ThinkingHome.Plugins.WebUI</kbd>)
		</p>
		<pre>
[Plugin]
[AppSection(<strong>"My plugin"</strong>,			// название рездела
		<strong>SectionType.Common</strong>,		// тип раздела
		<strong>"/my-plugin/my-file.js"</strong>,	// URL
		<strong>"ThinkingHome.Plugins.MyPlugin.Resources.my-file.js"</strong>)]
public class MyPlugin : PluginBase
{
	...
}
</pre>
		<p>
			Кроме URL и пути к файлу ресурса, в параметрах атрибута <code>[AppSection]</code>
			необходимо указать название раздела и его тип ("пользовательский" или "системный"). После этого ссылка на раздел автоматически
			добавится в нужный список разделов.
		</p>
		<p>
			<img class="img-responsive ths-image" src="~/Content/images/section-in-list.png" />
		</p>
		<h2 id="views">Отображение данных на странице</h2>
		<p>
			Данные появляются в модуле из источника данных (например они могут быть получены с сервера или введены пользователем).
			Будем считать, что изначально данные существуют в виде объектов JavaScript. Для примера создадим объекты внутри приложения.
		</p>
		<pre>
start: function () {
	...
	var items = [
		{ id: 1, name: 'Lev Tolstoy' },
		{ id: 2, name: 'Ivan Turgenev' },
		{ id: 3, name: 'Nikolay Gogol' },
		{ id: 4, name: 'Alexander Pushkin' }
	];
	
	var model = new backbone.Collection(items);
	...
}
</pre>
		<p>
			В приведенном примере мы создали массив объектов, каждый из которых имеет два поля: id (номер объекта) и name (текстовое поле).
			Также мы создали специальный объект - модель для нашего нашего массива (с помощью библиотеки Backbone.js). Благодаря Backbone.js
			мы имеем средства для удобной работы с нашими объектами. Например, мы легко можем задать порядок сортировки для коллекции
			и при обращении к ее элементам они будут выдаваться в нужном порядке.
		</p>
		<pre>
		...
		var model = new backbone.Collection(items);
		model.comparator = 'name';
		
		model.sort();
		model.each(function(obj) {
			console.log(obj.get('name'));
		});
		
		/*
			будет выведено:
				Alexander Pushkin
				Ivan Turgenev
				Lev Tolstoy
				Nikolay Gogol
		*/
</pre>
		<p>
			Обратите внимание, объект <code>backbone</code>, к которому мы обращались при создании модели - это входной параметр нашей функции инициализации
			модуля. Это третий по списку параметр, а значит, в качестве его значения будет передан объект, соответствующий третьему пункту нашего списка
			зависимостей (т.е. туда будет передан объект Backbone из библиотеки backbone.js).
		</p>
		<p>
			Для отображения данных в системе используются представления (views) из marionette.js. Представления - это специальные объекты,
			которые знают, как отобразить данные на странице и какие события сгенерировать при взаимодействии пользователя
			с элементами интерфейса.
		</p>
		<p>
			Сначала необходимо описать параметры представления и его поведения. Далее нужно создать его объект - экземпляр представления
			и передать туда модель с данными. После этого нужно вызвать команду "отобразить представление на странице".
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore'],
	function (application, marionette, backbone, _) {

		<strong>// описываем параметры представлений для коллекции и для ее отдельного элемента</strong>
		var peopleView = marionette.ItemView.extend({
				template: _.template('<%= name %> (<%= id %>)')			<strong>// шаблон отображения</strong>
			});
		
		var peoplesView = marionette.CompositeView.extend({
				template: _.template('&lt;h1>Peoples&lt;/h1>&lt;div id="list">&lt;/div>'),	<strong>// шаблон отображения</strong>
				childView: peopleView,			<strong>// представление для элемента коллекции</strong>
				childViewContainer: '#list'		<strong>// контейнер, куда будут добавляться элементы</strong>
			});
		
		
		var module = {
			<strong>start</strong>: function () {
				...
		
				<strong>// создаем экземпляр представления и передаем туда данные (модель Backbone.Collection)</strong>
				var view = new peoplesView({ collection: model });
	
				<strong>// отображаем представление на странице</strong>
				application.setContentView(view);
			}
		};
		return module;
	});
</pre>
		<p>
			Обратите внимание, объекты marionette и application - это тоже входные параметры функции инициализации.
		</p>
		<p>
			Как видите, представление определяется при помощи вызова функции <code>extend</code> для одного из
			базовых представлений из библиотеки marionette.js. В функцию <code>extend</code> передается объект,
			определяющий параметры, которыми будет расширено базовое представление.
		</p>
		<h3>Представление для отображения объекта с данными</h3>
		<p>
			Для отображения объекта с данными используйте базовое представление
			<a target="_blank" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.itemview.md">marionette.ItemView</a>.
			Для него необходимо задать только шаблон отображения. При создании экземпляра представления
			объект с данными (Backbone.Model) нужно поместить в поле <code>model</code>.
		</p>
		<pre>
<strong>// определяем параметры представления</strong>
var myView = marionette.ItemView.extend({
	template: _.template('<%= id %>: <%= field1 %> (<%= field2 %>)')
});
...
<strong>// создаем экземпляр представления</strong>
var view = new myView({ <strong>model</strong>: myDataObject });
...
</pre>
		<h3>Представление для отображения коллекции объектов</h3>
		<p>
			Для отображения <em>коллекции</em> объектов используйте базовое представление
			<a target="_blank" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.compositeview.md">marionette.CompositeView</a>.
			Кроме шаблона, необходимо указать представление для отображения дочерних объектов
			(элементов коллекции) и селектор для контейнера, в который будет добавлена разметка для дочерних объектов.

			При создании экземпляра представления
			объект с данными (Backbone.Collection) нужно поместить в поле <code>collection</code>.
		</p>
		<pre>
<strong>// определяем параметры представления</strong>
var myListView = marionette.CompositeView.extend({
	template: _.template('&lt;h1>Title&lt;/h1>&lt;div id="list">&lt;/div>'),
	<strong>childView</strong>: myView,
	<strong>childViewContainer</strong>: '#list'
});
<strong>// создаем экземпляр представления</strong>
var view = new myListView({ <strong>collection</strong>: myCollection });
...
</pre>
		<h3>Макет страницы (layout)</h3>
		<p>
			Если страница состоит из нескольких независимых блоков, вы можете создать для каждого из них
			отдельное представление и отобразить вместе на одной странице с помошью <em>макета страницы</em>
			(layout view). Внутри layout view вы можете описать несколько <em>областей</em> (region)
			и отобразить в каждой из них отдельное представление. Например если на странице должен быть список
			элементов и панель с условиями фильтрации, то вы можете создать отдельное представление
			для списка, отдельное представление для фильтров и при изменении фильтров обновлять представление
			для списка (т.е. обновлять только одну из областей страницы).
		</p>
		<p>
			Для описания <em>макета страницы</em> используйте базовое представление
			<a target="_blank" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.layoutview.md">marionette.LayoutView</a>.
			Как и для других представлений, для макета нужно задать шаблон отображения.
			Области для дочерних представлений определяются при помощи параметра <code>regions</code>.
			В качестве его значения необходимо указать объект, каждое поле котрого будет соответствовать
			отдельному региону страницы. Название поля - это название региона, а значение поля - строка,
			задающая селектор для DOM элемента, в котором буде отображаться дочернее представление.
		</p>
		<p>
			Например:
		</p>
		<pre>
<strong>// определяем параметры представления</strong>
var myLayout = marionette.LayoutView.extend({
	template: _.template(layoutTemplate),
		<strong>regions</strong>: {
			<strong>filter</strong>: '#region-filter',
			<strong>list</strong>: '#region-list'
	}
});
</pre>
		<p>
			Чтобы отобразить внутри региона дочернее представление,
			необходимо у соответствующего поля макета вызвать метод <code>show</code> и передать в него
			экземпляр дочернего представления.
		</p>
		<pre>
		
<strong>// создаем экземпляр layout view и добавляем его на страницу</strong>
var layoutView = new myLayout();
application.setContentView(layoutView);

<strong>// создаем экземпляры дочерних представлений</strong>
var filterView = new myFilterView( ... );
var listView = new myListView( ... );

<strong>// отображаем дочерние представления на странице</strong>
layoutView.<strong>filter</strong>.show(filterView);
layoutView.<strong>list</strong>.show(listView);
</pre>
		<p>
			Обратите внимание, в приведенном примере <code>layoutView.filter</code> и <code>layoutView.list"</code> - это названия регионов. В соответствии
			с заданными нами параметрами макета страницы, представление <code>filterView</code> будет добавлено в
			блок с id = "region-filter" (селектор <code>"#region-filter"</code>), а представление
			<code>listView</code> будет
			отображаться в блоке с id = "region-list" (селектор <code>"#region-filter"</code>). Вместо селекторов по id
			можно использовать любые другие (например, по css-классу).
		</p>
		<h3>Шаблоны</h3>
		<p>
			Шаблон - это строка, содержащая HTML разметку для отображения объекта с данными. Для формирования
			разметки по шаблону используется движок шаблонов из библиотеки
			<a href="http://underscorejs.org/#template" target="_blank">underscore.js</a>.
			Места для вставки значений полей объекта обозначаются конструкцией <code>&lt;%= fieldName %></code>,
			где <em>fieldName</em> - это название поля объекта. Если необходимо, чтобы при выводе значения поля
			экранировались символы HTML, используйте конструкцию вида <code>&lt;<strong>%-</strong> fieldName %></code>.
		</p>
		<pre>
var data = { title: 'Test', content: '&lt;p>This is content.&lt;/p>'}
var t1 = _.template('<%= title %>&lt;br /><%= content %>)');	// будет выведено: <strong>Test&lt;br />&lt;p>This is content.&lt;/p></strong>
var t2 = _.template('<%= title %>&lt;br /><%- content %>)');	// будет выведено: <strong>Test&lt;br />&amp;lt;p&amp;gt;This is content.&amp;lt;/p&amp;gt;</strong>
</pre>
		<h3>Размещение шаблонов в отдельных файлах</h3>
		<p>
			В предыдущем примере мы использовали для отображения данных очень простые шаблоны и они были
			размещены непосредственно в коде (шаблоны в виде строки передавались в функцию <code>_.template</code>).
			Например:
		</p>
		<pre>
...
template: _.template(<strong>'<%= name %> (<%= id %>)'</strong>)
...
</pre>
		<p>
			Для небольших шаблонов такой подход довольно удобен, но более сложные шаблоны удобнее будет вынести в отдельные файлы.
		</p>
		<ul>
			<li>не нужно будет беспокоиться об экранировании кавычек (в отличие от варианта с размещением шаблонов в коде);</li>
			<li>будет работать подсветка и автокомплит в IDE;</li>
			<li>глядя на файловую структуру сразу будет понятно, где находятся шаблоны:</li>
			<li>и т.д.</li>
		</ul>
		<p>
			Для подключения шаблонов из отдельных файлов, в первую очередь, нужно поместить файлы с шаблонами
			в ресурсы плагина и настроить доступ к ним по  HTTP. Для этого необходимо установить для файлов с
			шаблонами параметр <em>Build action</em> = <em>EmbeddedResource</em>, пометить класс плагина
			атрибутом <code>ThinkingHome.Plugins.Listener.Attributes.HttpResourceAttribute</code>
			(нужно добавить отдельный атрибут для каждого файла шаблона). В параметрах атрибута
			<code>[HttpResource]</code> необходимо указать путь к файлу ресурсов и URL, котрый будет использоваться
			для загрузки файла по протоколу HTTP.
		</p>
		<p>
			В стандартных плагинах файлы шаблонов имеют расширение .tpl (соткращение от "template"). Рекомендуем вам
			использовать это же расширение для ваших шаблонов (хотя это и не обязательно - по большому счету, расширение
			может быть любым).
		</p>
		<p>
			Вот пример подключнения шаблона для страницы с прогнозом погоды:
		</p>
		<pre>
[HttpResource(
	"/webapp/weather/forecast.tpl",						<strong>// URL для загрузки файла</strong>
	"ThinkingHome.Plugins.Weather.Resources.js.forecast.forecast.tpl")]	<strong>// путь к файлу в ресурсах плагина</strong>
public class WeatherUIPlugin : PluginBase
{
	...
}
</pre>
		<p>
			Для обращения к файлам шаблонов на стороне клиента необходимо добавить их в список зависимостей
			модуля в виде <code>text!&lt;URL файла с шаблоном></code>. Содержимое шаблона будет передано как
			входной параметр в функцию инициализации модуля.
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore', <strong>'text!myplugin/mytemplate.tpl'</strong>],
	function (application, marionette, backbone, _, <strong>myTemplate</strong>) {
	
		var myView = marionette.ItemView.extend({
				template: _.template(<strong>myTemplate</strong>)
			});
		var module = {
		<strong>start</strong>: function () {
				
				var model = ...
				var view = new myView({ model: model });
				application.setContentView(view);
			}
		};
		return module;
	});
</pre>
		<h3>Размещение кода представлений в отдельных файлах</h3>
		<p>
			Если ваш плагин имеет несколько сложных представлений, вполне вероятно, вы захотите разместить
			их код в отдельном файле. В этом случае найти их будет значительно легче (согласитесь, найти файл в
			файловой системе проще, чем найти нужный фрагмент в одном большом файле), а также намного удобнее будет
			работать с кодом (т.к. остальной клиентский код не будет отвлекать ваше внимание). Кроме того, представления обычно
			имеют зависимости, которые больше нигде не используются (файлы с шаблонами). Очень удобно, когда
			эти зависимости инкапсулированы в отдельном файле с представлениями.
		</p>
		<p>
			Для размещения представлений в отдельном файле создайте отдельный модуль для require.js,
			укажите необходимые зависимости и верните из функции инициализации модуля объект,
			содержащий ваши представления. Т.к. файл с представлениями не является основным файлом плагина,
			функцию <code>start</code> в возвращаемый объект добавлять не обязательно.
		</p>
		<p>
			В результате должно получиться примерно так:
		</p>
		<pre>
/*************************************************
 * файл с кодом представлений: my-plugin/views.js *
 *************************************************/
define(
	['app', 'marionette', 'backbone', 'underscore', 
	 'text!myplugin/layout-template.tpl',	// общий шаблон страницы
	 'text!myplugin/list-template.tpl',	// шаблон для списка объектов
	 'text!myplugin/item-template.tpl'	// шаблон для элемента списка
	 ],
	function (application, marionette, backbone, _, tmplLayout, tmplList, tmplListItem) {
	
		
		<strong>// описываем наши представления</strong>
		var myLayout = marionette.LayoutView.extend({
				template: _.template(<strong>tmplLayout</strong>),
				...
			});
		var myListItemView = marionette.ItemView.extend({
				template: _.template(<strong>tmplListItem</strong>),
				...
			});
		var myListView = marionette.CompositeView.extend({
				template: _.template(<strong>tmplList</strong>),
				childView: myListItemView,
				...
			});
		<strong>// возвращаем объект, с помошью которого другие модули
		// будут использовать наши представления
		return {
			layout: myLayout,
			listView: myListView
		};</strong>
	});
</pre>
		<p>
			Как и остальные файлы содержащие клиентский код, файл с представлениями необходимо поместить в ресурсы плагина.
			Также необходимо указать URL для файла, но вместо атрибута <code>[AppSection]</code>, который
			мы использовали для основного модуля, нужно добавить другой атрибут <code>[JavaScriptResource]</code>
			из пространства имен <code>ThinkingHome.Plugins.WebUI.Attributes</code>. Если бы мы использовали
			атрибут <code>[AppSection]</code>, система автоматически добавила бы новый пункт в навигационное
			меню и при его выборе попыталась бы вызвать у модуля с представлениями метод <code>start</code>
			(а в данном случае нам этого не нужно).
		</p>
		<p>
			В результате должен получиться примерно такой код:
		</p>
		<pre>
[Plugin]
[AppSection("My plugin", SectionType.Common, "/my-plugin/index.js", "ThinkingHome.Plugins.MyPlugin.Resources.index.js")]
<strong>[JavaScriptResource("/my-plugin/views.js", "ThinkingHome.Plugins.MyPlugin.Resources.views.js")]</strong>
public class MyPlugin : PluginBase
{
	...
}
</pre>
		<p>
			После этого можно обращаться к модулю с представлениями из основного модуля.
			Для этого нужно добавить модуль с представлениями в список зависимостей основного модуля
			(<em>указать его URL без начального символа "/" и расширения ".js"</em>), добавить соответствующий
			входной параметр в его функцию инициализации и обратиться к его полям,
			содержащим наши представления.
		</p>
		<p>
			Примерный код основного модуля:
		</p>
		<pre>
define(
	['app', 'marionette', 'backbone', 'underscore', <strong>'my-plugin/views'</strong>],
	function (application, marionette, backbone, _, <strong>views</strong>) {
	
		// входной параметр <strong>views</strong> - это объект, который
		// был возвращен из функции инициализации модуля с представлениями
		var module = {
		<strong>start</strong>: function () {
				
				var model = ...
				var view = new <strong>views.listView</strong>({ collection: model });
				application.setContentView(view);
			}
		};
		return module;
	});
</pre>
		<p>
			Обратите внимание, мы подключаем только модуль с представлениями. Все файлы, от которых
			он зависит, будут загружены автоматически, в соответствии с его списком зависимостей.
		</p>
		<h3>Подключение css-файлов</h3>
		<p>
			По умолчанию приложение уже содержит ссылку на стили
			<a href="http://getbootstrap.com" target="_blank">Twitter Bootstrap</a>
			и вы можете использовать при верстке css-классы оттуда. Хотя в большинстве случаев стилей из
			Twitter Bootstrap будет достаточно, скорее всего возникнут ситуации, когда нужно подключить
			дополнительные файлы со стилями. Например, это может потребоваться, если у вас много css-классов
			(и вы хотите вынести их в отдельный файл) или при подключении внешних библиотек, имеющих
			собственные файлы со стилями.
		</p>
		<p>
			Подключить дополнительные файлы стилей очень легко. Необходимо поместить их в ресурсы плагина
			аналогично файлам скриптов (.js) и шаблонов (.tpl). После этого нужно пометить класс плагина
			дополнительным атрибутом <code>ThinkingHome.Plugins.WebUI.Attributes.CssResourceAttribute</code>.
		</p>
		<p>
			Атрибут <code>[CssResource]</code> похож на знакомые нам атрибуты <code>[HttpResource]</code>
			и <code>[JavaScriptResource]</code>, с помощью которых мы задавали URL для файлов шаблонов и дополнительных
			модулей с кодом. Атрибут <code>[CssResource]</code> отличается тем, что
			содержит дополнительный параметр <code><strong>bool</strong> AutoLoad</code>. Если указать
			для него значение <code>true</code>, то файл со стилями будет автоматически подключен в приложение.
		</p>
		<p>
			Например, вот так подключается файл со стилями для погодных иконок:
		</p>
		<pre>
[CssResource(
	"/webapp/weather/css/weather-icons.min.css", 
	"ThinkingHome.Plugins.Weather.Resources.css.weather-icons.min.css", 
	<strong>AutoLoad = true</strong>)]
</pre>
		<h2 id="events">События</h2>
		<p>
			При помощи событий вы можете выполнить нужные действия при взаимодействии пользователя в интерфейсом.
			Например, вы можете отобразить сообщение при клике мышью на кнопку или отобразить подсказку при наведении
			курсора мыши на элементы интерфейса.
		</p>
		<p>
			Общий принцип очень простой: вы определяете в параметрах представления, в каких ситуациях нужно
			<em>сгенерировать событие</em>, а потом назначаете функцию-обработчик события. При возникновении
			указанных ситуаций будут автоматически вызваны обработчики событий.
		</p>
		<h3>Определение событий</h3>
		<p>
			Определить события для представления можно при помощи параметра <code>triggers</code>. В качестве его
			значения нужно указать объект, каждое поле котрого соответствует некоторому событию. Название поля
			описывает ситуацию, в окторой должно генерироваться событие. Сначала пишется тип события (например,
			"click" или "mouseover"), далее через пробел указывается селектор для элемента интерфейса, для которого
			нужно обрабатывать указанной событие. В качестве значения поля нужно указать <em>имя события</em>. Имя события
			используется для назначения функций-обработчиков события.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	...
	triggers: {
		'<strong>click</strong> .do-something': 'something:do:it',
		'<strong>click</strong> #btn-submit': 'submit:form'
	}
});
</pre>
		<h3>Назначение обработчиков событий</h3>
		<p>
			При создании экземпляра представления можно назначить обработчики событий при помощи функции
			<code>on</code>. В качестве первого параметра необходимо передать имя события, в качестве второго
			параметра - функцию, которая будет вызвана при возникновении события.
		</p>
		<pre>
var view = new MyView();
view.on("something:do:it", function(args){
  alert("I DID IT!");
});
</pre>
		<p>
			Внутри функции обработчика события можно обращаться к экземпляру представления при помощи
			переменной <code>this</code>. С ее помощью можно получить доступ к модели (при помощи
			поля <code>model</code>) и элементам интерфейса (при помощи метода <code>$</code>).
			Также можно обратиться к корневому элементу интерфейса через поле <code>$el</code>.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	template: _.template('&lt;input id="input-bg-color" placeholder="enter new bg color" />')
	triggers: {
		'<strong>change</strong> #input-bg-color': 'color:changed'
	}
});
...
var view = new MyView(model: myObject);
view.on("color:changed", function(){
	
	var newColor = this.$('#input-bg-color').val();
	this.$el.css('background-color', newColor);
});
</pre>
		<p>
			Кроме вызова функции <code>on</code> есть еще один вариант назначения обработчиков событий.
			Вы можете описать в параметрах представления функцию, название которой соответствует названию
			события в <a href="http://en.wikipedia.org/wiki/CamelCase" target="_blank">camelCase</a>
			с префиксом <em>"on"</em>.
		</p>
		<pre>
var MyView = marionette.ItemView.extend({
	...
	triggers: {
		'change #input-bg-color': '<strong>color:changed</strong>'
	},
	<strong>onColorChanged</strong>: function(model: myObject){
		var newColor = this.$('#input-bg-color').val();
		this.model.set('color', newColor);
	}
});
</pre>
		<p>
			По большому счету, указанные способы назначения обработчиков событий отличаются только местом, где
			описана функция-обработчик: в первом случае она описана рядом с кодом, использующим представление,
			а во втором случае - в параметрах представления. Обработчики событий, связанных с <em>операциями над
				элемнетами представления
			</em>лучше размещать в параметрах представления, а обработчики, связанные
			с <em>предметной областью</em> вашего плагина лучше размещать снаружи. Например, вывод подсказки при
			наведении курсора мыши лучше разместить в представлении, а отправку запроса к серверу при нажатии кнопки
			"Сохранить" лучше разместить в коде, создающем экземпляр представления.
		</p>
		<h3>События дочерних представлений</h3>
		<p>
			Все события дочерних представлений <em>всплывают</em> в родительское представление. При этом к их имени
			добавляется префикс <em>"childview:"</em>. Например, предположим, что у вас есть список, в котором у каждого
			элемента есть кнопка "Удалить" и она генерирует событие "delete:item". В этом случае, в родительском
			представлении вы можете обработать нажатие на эту кнопку, подписавшись (любым способом) на
			событие <em>"childview:delete:item"</em>. При этом переменная <code>this</code> смотрит на
			<em>родительское представление</em>, а дочернее представление, в котором произошло событие,
			передается в функцию-обработчик в качестве первого аргумента.
		</p>
		<pre>
// представление для оторажения элемента коллекции
var MyItemView = marionette.ItemView.extend({
	template: _.template('<%= name %> &lt;a href="#" class="btn-delete">Del&lt;/a>'),
	triggers: {
		'click .btn-delete': <strong>'delete:item'</strong>
	}
});
// представление для отображения коллекции
var listView = marionette.CompositeView.extend({
	...
	childView: MyItemView
});
...
var view = new listView({ collection: model });
view.on(<strong>'childview:delete:item'</strong>, function(<strong>childView</strong>){
	// <strong>this</strong> - родительское представление
	// <strong>childView</strong> - дочернее представление
	var name = childView.model.get('name');
	alert(name + ' deleted!');
});
</pre>
		<h2 id="requests">Запросы к серверу</h2>
		<p>
			Как правило, интерфейс запрашивает данные, которые нужно отобразить пользователю, с сервера
			при помощи отдельного ajax запроса (например, можно вызвать методы плагинов, доступные по
			протоколу HTTP). Это очень легко сделать средствами jQuery. Т.к. веб-интерфейс загружается
			с того же сервера, где находится HTTP API плагинов, нужно использовать относительные URL
			(от корня сайта, т.е. начинающиеся с символа "/").
		</p>
		<p>
			Например, вот таким образом в UI загружается список сценариев:
		</p>
		<pre>
// метод плагина
[HttpCommand(<strong>"/api/scripts/list"</strong>)]
public object GetScriptList(HttpRequestParams request)
{
	...
	return list;
}
---
// вызов метода плагина (на стороне клиента) - метод GET
$.getJSON(<strong>'/api/scripts/list'</strong>)
	.done(function (items) {
		...
	})
	.fail(function () {
		...
	});
</pre>
		<p>
			Пример запроса с параметрами:
		</p>
		<pre>
// метод плагина
[HttpCommand(<strong>"/api/scripts/run"</strong>)]
public object GetScriptList(HttpRequestParams request)
{
	Guid scriptId = request.GetRequiredGuid(<strong>"scriptId"</strong>);
	
	...
	return null;
}
---	
	
// пример вызова методом POST
$.post(<strong>'/api/scripts/run'</strong>, { <strong>scriptId</strong>: "8819B702-55BB-44CD-85C6-629D949ACAF6" })
	.done(function () {
		...
	});
</pre>
		<h3 id="deferred">Использование jQuery.Deferred для управления асинхронными запросами</h3>
		<p>
			Обращения к серверу являются асинхронными. Это значит, что после начала выполнения запроса
			программа, запустившая его, продолжит свое выполнение, не дожидаясь его окончания.
			Для управления асинхронными операциями в библиотеке jQuery имеется очень удобный
			инструмент -
			<a href="http://api.jquery.com/category/deferred-object/" target="_blank">jQuery.Deferred</a>.
		</p>
		<h4>Основная идея</h4>
		<p>
			<em>Deferred object</em> хранит состояние асинхронной операции -
			<em>"выполняется"</em>, <em>"завершена успешно"</em> или <em>"завершена неудачей"</em>.
			Имея deferred object, можно определить, в каком состоянии сейчас операция или
			можно добавить функции-обработчики, которые автоматически вызовутся при переходе
			в нужное состояние. Например, можно автоматически выполнить нужную функцию при успешном
			завершении операции.
		</p>
		<p>
			Удобство deferred object состоит в том, что его можно сохранить в переменную или
			вернуть в качестве результата функции. Например, вы можете написать функцию,
			которая запускает ajax запрос и возвращает deferred object, хранящий его состояние,
			чтобы вызывающая программа могла узнать, когда выполнение запроса завершится. Таким образом,
			можно отделить код подготовки и выполнения ajax запроса (внутри функции) от кода обработки его
			результата (снаружи функции, в вызывающей программе). Это значит, части нашей программы будут
			иметь меньше зависимостей и вам будет легче работать с кодом.
		</p>
		<h4>Как создать deferred object</h4>
		<p>
			Создать deferred object очень просто: нужно вызвать функцию <code>$.Deferred()</code>.
		</p>
		<pre>
var obj = $.Deferred();
</pre>
		<h4>Как узнать состояние операции</h4>
		<p>
			Deferred object имеет специальный метод <em>state()</em> позволяющий узнать текущее состояние асинхронной операции.
			Метод возвращает строковое значение:
		</p>
		<ul>
			<li>
				<em>"pending"</em> - означает, что в текущий момент операция выполняется (т.е. <em>не завершена успешно</em>
				и <em>не завершена неудачей</em>);
			</li>
			<li>
				<em>"resolved"</em> - означает, что операция <em>завершена успешно</em>;
			</li>
			<li>
				<em>"rejected"</em> - означает, что операция <em>завершена неудачей</em>.
			</li>
		</ul>
		<p>
			Например:
		</p>
		<pre>
if (obj.state() === "resolved")
{
	alert('Success!');
}
</pre>
		<h4>Как изменить состояние</h4>
		<p>
			Изменить состояние можно при помощи методов <code>reject()</code> и <code>resolve()</code>.
		</p>
		<ul>
			<li>
				<em>reject(args)</em> - переводит deferred object в состояние <em>"операция завершена неудачей"</em>;
			</li>
			<li>
				<em>resolve(args)</em> - переводит deferred object в состояние <em>"операция завершена успешно"</em>.
			</li>
		</ul>
		<p>
			При изменении состояния вызываются все нужные функции-обработчики. При этом в вызываемые
			функции-обработчики передается набор параметров, который был указан в качестве аргументов функции
			<em>resolve</em> или <em>reject</em>.
		</p>
		<p>
			Например:
		</p>
		<pre>
function loadData() {
	var obj = $.Deferred();
	$.getJSON('/api/my-plugin/get-data')
		.done(function (data) {
		
			<strong>// после получения данных с сервера создаем для них модель 
			// меняем состояние операции на "завершена успешно"</strong>
			var model = new backbone.Model(data);
			<strong>obj.resolve(model);</strong>
		});
	return obj;
}
</pre>
		<h4>Как выполнить действия при изменении состояния</h4>
		<p>
			Имея <em>deferred object</em>, можно легко назначить функции, которые будут автоматиченски
			вызваны при переходе в заданное состояние. Для этого deferred object предоставляет методы
			<em>"done"</em>, <em>"fail"</em> и <em>"always"</em>.
		</p>
		<ul>
			<li>
				<em>done(fn)</em> - функция <em>fn</em>, переданная в качестве входного параметра, будет вызвана при переходе в состояние
				<em>"операция завершена успешно"</em>;
			</li>
			<li>
				<em>fail(fn)</em>  - функция <em>fn</em>, переданная в качестве входного параметра, будет вызвана при переходе в состояние
				<em>"операция завершена неудачей"</em>;
			</li>
			<li>
				<em>always(fn)</em> - функция <em>fn</em>, переданная в качестве входного параметра, будет вызвана при любом варианте завершения
				операции (как успешном, так и неудачном).
			</li>
		</ul>
		<p>
			Например:
		</p>
		<pre>
var module = {
	start: function () {
		
		var query = loadData();	// функция из предыдущего примера
			
		query.done(function(data) {
			
			<strong>// при успешном завершении ajax запроса отображаем полученные данные на странице</strong> 
			var view = new myView({model: data});
			application.setContentView(view);
		});
		
		query.fail(function() {
		   
			<strong>// при ошибке выводим сообщение "error"</strong>
			alert("error");
		});
	}
};
</pre>
		<p>
			Если вызвать метод добавления обработчика несколько раз, то будет добавлено несколько обработчиков.
		</p>
		<p>
			Также обратите внимание, что, если в момент добавления обработчика deferred object уже находится в заданном
			состоянии, то обработчик будет вызван сразу при добавлении.
		</p>
		<h4>Как дождаться выполнения нескольких запросов</h4>
		<p>
			Для того, чтобы дождаться выполнения нескольких асинхронных операций, используйте метод <code>$.when(deferreds)</code>.
			В качестве входных параметров он принимает несколько deferred-объектов, каждый из которых соответствует асинхронной операции.
			Метод <code>$.when</code> возвращает новый deferred object. Он примет состояние "выполнено успешно", когда его примут все аргументы
			$.when(). Если один из них перейдет в состояние "завершено неудачно", то созданный deferred примет это состояние вслед за ним.
		</p>
		<p>
			Например:
		</p>
		<pre>
var d1 = new $.Deferred();
var d2 = new $.Deferred();
var d3 = new $.Deferred();
$.when( d1, d2, d3 ).always(function ( v1, v2, v3 ) {
  
	console.log("v1", v1 ); // v1 is undefined
	console.log("v2", v2 ); // v2 is "abc"
	console.log("v3", v3 ); // v3 is an array [ 1, 2, 3, 4, 5 ]
});
d1.resolve();
d2.resolve( "abc" );
d3.resolve( 1, 2, 3, 4, 5 );
</pre>
		<h3>Размещение кода обращений к серверу в отдельном файле</h3>
		<p>
			При любом обращении к серверу, необходимо задать параметры ajax запроса (как минимум,
			URL запроса и список его GET или POST параметров). После получения ответа от сервера,
			как правило, нужно создать модель для полученных данных (
			<a href="http://backbonejs.org/#Model" target="_blank">backbone.Model</a> или
			<a href="http://backbonejs.org/#Collection" target="_blank">backbone.Collection</a>).
			Также может потребоваться обработка ошибок или какая-либо другая специфическая логика.
			Таким образом, код, связанный с обращением к серверу, может быть довольно сложным.
			Возможно, вам захочется вынести его в отдельный файл. Сделать это очень легко!
		</p>
		<p>
			По аналогии с представлениями, необходимо разместить файл с кодом обращений к серверу
			в ресурсах плагина и задать для него URL, пометив плагин атрибутом <code>[JavaScriptResource]</code>.
			Также, как и в случае с представлениями, необходимо описать отдельный модуль для require.js
			и вернуть из его функции инициализации объект, с помощью котрого другие модули будут запускать
			наши запросы к серверу.
		</p>
		<pre>
/***********************************************************
 * файл с логикой запросов к серверу: my-plugin/queries.js *
 ***********************************************************/
define(
	['app', 'backbone', 'jquery'],
	function (application, backbone, $) {
		var api = {
			
			<strong>// пример запроса без параметров</strong>
			loadData: function(){
								
				<strong>// пример обращения к серверу</strong>				
				var obj = $.Deferred();
				$.getJSON('/api/my-plugin/get-data')
					.done(function (data) {
						
						var model = new backbone.Model(data);
						<strong>obj.resolve(model);</strong>
					});
	
				return obj;
			},
			
			<strong>// пример запроса с параметрами</strong>
			saveObject: function(obj){	
				...
			}
		};	
		<strong>return api;</strong>
	});
</pre>
		<p>
			После этого можно добавить наш модуль в список зависимостей основного модуля
			(или любого другого) и вызывать запросы к серверу.
		</p>
		<pre>
define(
	[... , <strong>'my-plugin/queries'</strong>],
	function (... , <strong>queries</strong>) {
	
		var module = {
			start: function () {
				
				<strong>var q = queries.loadData();</strong>
				
				q.done(function(<strong>data</strong>) {
			
					var view = new myView({model: <strong>data</strong>});
					
					// если внутри представления сгенерировано событие "save:my:object", отправляем запрос на сервер
					view.on('save:my:object', function(){
					
						var model = this.model;		// получаем модель из представления
						<strong>queries.saveObject(model);</strong>	// запускаем запрос к серверу
					})

					...
					// отображаем представление на странице
					application.setContentView(view);
				});
			}
		};

		return module;
	});
</pre>
		<h2 id="tiles">Элементы рабочего стола</h2>
		<p>
			"Рабочий стол" (он же "стартовая страница") - это страница, которую пользователь видит
			в первую очередь, когда открывает веб-интерфейс управления домом. На рабочем столе могут размещаться
			элементы интерфейса - небольшие панели, отображающие полезную информацию. При клике на такой панели
			может быть выполнено какое-либо действие или переход в другой раздел. Например, на панели может
			отображаться информация о текущей погоде, а при клике на ней - переход в раздел
			с прогнозом погоды.
		</p>
		<div class="row">
			<div class="col-md-12">
				<img class="ths-image img-responsive" src="~/Content/images/start-page-scheme.png"
					alt="Стартовая страница" title="Стартовая страница" />
			</div>
		</div>
		<p>
			Каждый элемент рабочего стола относится к определенному типу. Например, типы элементов:
			"погода", "будильники", "запуск сценария" и т.д. Тип элемента определяет, какая информация
			на нем отображается и какие действия выполняются, если пользователь кликнет на него. Например,
			элемент "погода" отображает текущую погоду и при клике открывает раздел с прогнозом погоды.
			Элемент "запуск сценария" отображает название сценария, а при клике на нем - запускает этот сценарий.
		</p>
		<p>
			Плагины могут добавлять в систему собственные типы элементов рабочего стола. Например, тип
			"запуск сценария" реализован в плагине <em>ThinkingHome.Plugins.Scripts</em> (а если этот плагин 
			удалить, элементы "запуск сценария" не будут отображаться).
		</p>
		<p>
			Элементы любого типа могут быть сколько угодно раз добавлены на рабочий стол. При этом для каждого из них
			можно указать разные параметры. Например, для элемента "погода" в качестве параметра
			используется ID города для которого нужно отображать погоду на рабочем столе. Для элемента "запуск сценария"
			входной параметр - это ID сценария.
		</p>
		<p>
			Каждый элемент рабочего стола имеет <em>заголовок (title)</em> и <em>содержимое (content)</em>.
			Также элемент может иметь <em>пиктограмму (icon)</em> и для элемента может быть указан <em>css класс</em>.
		</p>
		<h3>Описание собственных элементов рабочего стола</h3>
		<p>
			Для создания нового типа элемента необходимо добавить в плагин новый класс, унаследованный от
			базового класса <code>ThinkingHome.Plugins.WebUI.Tiles.TileDefinition</code> и переопределить
			его метод <code>FillModel</code>. Также необходимо
			пометить этот класс атрибутом <code>ThinkingHome.Plugins.WebUI.Tiles.TileAttribute</code>.
		</p>
		<pre>
using ThinkingHome.Plugins.WebUI.Tiles;
...

[<strong>Tile</strong>]
public class ScriptsTileDefinition : <strong>TileDefinition</strong>
{
	public override void FillModel(TileModel model, dynamic options)
	{
		...
	}
}
</pre>
		<p>
			Метод <em>FillModel</em> Вызывается непосредственно перед отображением элемента пользователю.
			В качестве входных параметров он получает <em>модель элемента</em> и его <em>параметры</em>.
		</p>
		<p>	
			<em>Модель</em> элемента рабочего стола (параметр <code>model</code>) - это объект, описывающий его 
			основные свойства. В методе <code>FillModel</code> необходимо заполнить этот объект нужной 
			информацией. Например, с помощью свойств модели можно задать заголовок и содержание элемента.
		</p>
		<p>
			Входной параметр <code>options</code> содержит параметры отображаемого элемента,
			заданные при его добавлении на рабочий стол. Например, для элемента "запуск сценария"
			параметром может являться ID запускаемого сценария, а для элемента "погода"
			параметром может являться ID горда, для которого нужно отображать погоду.
		</p>
		<p>
			Например, элемент "запуска сценария" заполняет свою модель примерно так:
		</p>
		<pre>
public override void FillModel(TileModel model, dynamic options)
{
	try
	{
		UserScript script = GetScript(options.id);

		model.title = "Run script";
		model.content = script.Name;
	}
	catch (Exception ex)
	{
		model.content = ex.Message;
	}
}
</pre>
		<h3>Добавление на рабочий стол</h3>
		<h3>Иконки</h3>
		<p>
		</p>
		<h3>Действия</h3>
		<p>
		</p>
		<h2 id="modules">Модули, подключенные по умолчанию</h2>
		<p>
		</p>
	</div>
</div>

